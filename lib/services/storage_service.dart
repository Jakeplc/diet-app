import 'package:flutter/foundation.dart';
import 'package:hive/hive.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../models/user_profile.dart';
import '../models/food_item.dart';
import '../models/food_log.dart';
import '../models/weight_log.dart';
import '../models/meal_plan.dart';
import '../models/water_log.dart';
import '../models/recipe.dart';

class StorageService {
  // Box names
  static const String userBox = 'user_profile';
  static const String foodItemsBox = 'food_items';
  static const String foodLogsBox = 'food_logs';
  static const String weightLogsBox = 'weight_logs';
  static const String mealPlansBox = 'meal_plans';
  static const String waterLogsBox = 'water_logs';
  static const String settingsBox = 'settings';
  static const String recipesBox = 'recipes';

  // Initialize Hive and register adapters
  static Future<void> init() async {
    await Hive.initFlutter();

    // Register adapters (generated by build_runner)
    // Note: Run 'dart run build_runner build' to generate these
    // Hive.registerAdapter(UserProfileAdapter());
    // Hive.registerAdapter(FoodItemAdapter());
    // Hive.registerAdapter(FoodLogAdapter());
    // Hive.registerAdapter(WeightLogAdapter());
    // Hive.registerAdapter(MealPlanAdapter());
    // Hive.registerAdapter(WaterLogAdapter());

    // Open boxes (using dynamic for now until adapters are generated)
    await Hive.openBox(userBox);
    await Hive.openBox(foodItemsBox);
    await Hive.openBox(foodLogsBox);
    await Hive.openBox(weightLogsBox);
    await Hive.openBox(mealPlansBox);
    await Hive.openBox(waterLogsBox);
    await Hive.openBox(settingsBox);
    await Hive.openBox(recipesBox);

    // Seed food database on first run
    await _seedFoodDatabase();
  }

  // Seed basic food database for offline use
  static Future<void> _seedFoodDatabase() async {
    final box = Hive.box(foodItemsBox);
    if (box.isEmpty) {
      final commonFoods = [
        {
          'id': 'egg-1',
          'name': 'Egg (Large)',
          'barcode': '',
          'servingSize': 50.0,
          'calories': 70.0,
          'protein': 6.0,
          'carbs': 0.6,
          'fats': 5.0,
          'fiber': 0.0,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'protein',
          'isCustom': false,
        },
        {
          'id': 'chicken-1',
          'name': 'Chicken Breast (Grilled)',
          'barcode': '',
          'servingSize': 100.0,
          'calories': 165.0,
          'protein': 31.0,
          'carbs': 0.0,
          'fats': 3.6,
          'fiber': 0.0,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'protein',
          'isCustom': false,
        },
        {
          'id': 'rice-1',
          'name': 'White Rice (Cooked)',
          'barcode': '',
          'servingSize': 100.0,
          'calories': 130.0,
          'protein': 2.7,
          'carbs': 28.0,
          'fats': 0.3,
          'fiber': 0.0,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'grain',
          'isCustom': false,
        },
        {
          'id': 'banana-1',
          'name': 'Banana (Medium)',
          'barcode': '',
          'servingSize': 118.0,
          'calories': 105.0,
          'protein': 1.3,
          'carbs': 27.0,
          'fats': 0.4,
          'fiber': 3.1,
          'sugar': 14.0,
          'sodium': 0.0,
          'category': 'fruit',
          'isCustom': false,
        },
        {
          'id': 'broccoli-1',
          'name': 'Broccoli (Steamed)',
          'barcode': '',
          'servingSize': 100.0,
          'calories': 35.0,
          'protein': 2.4,
          'carbs': 7.0,
          'fats': 0.4,
          'fiber': 2.6,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'vegetable',
          'isCustom': false,
        },
        {
          'id': 'salmon-1',
          'name': 'Salmon (Grilled)',
          'barcode': '',
          'servingSize': 100.0,
          'calories': 206.0,
          'protein': 22.0,
          'carbs': 0.0,
          'fats': 13.0,
          'fiber': 0.0,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'protein',
          'isCustom': false,
        },
        {
          'id': 'oatmeal-1',
          'name': 'Oatmeal (Cooked)',
          'barcode': '',
          'servingSize': 100.0,
          'calories': 71.0,
          'protein': 2.5,
          'carbs': 12.0,
          'fats': 1.5,
          'fiber': 1.7,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'grain',
          'isCustom': false,
        },
        {
          'id': 'almonds-1',
          'name': 'Almonds (Raw)',
          'barcode': '',
          'servingSize': 28.0,
          'calories': 164.0,
          'protein': 6.0,
          'carbs': 6.0,
          'fats': 14.0,
          'fiber': 3.5,
          'sugar': 0.0,
          'sodium': 0.0,
          'category': 'snack',
          'isCustom': false,
        },
      ];

      for (var food in commonFoods) {
        await box.put(food['id'], food);
      }
    }
  }

  // User Profile
  static Future<void> saveUserProfile(UserProfile profile) async {
    final box = Hive.box(userBox);
    await box.put('profile', {
      'name': profile.name,
      'age': profile.age,
      'height': profile.height,
      'weight': profile.weight,
      'gender': profile.gender,
      'activityLevel': profile.activityLevel,
      'goal': profile.goal,
      'dietType': profile.dietType,
      'measurementSystem': profile.measurementSystem,
      'dailyCalorieTarget': profile.dailyCalorieTarget,
      'proteinTarget': profile.proteinTarget,
      'carbsTarget': profile.carbsTarget,
      'fatsTarget': profile.fatsTarget,
      'waterTarget': profile.waterTarget,
      'createdAt': profile.createdAt.toIso8601String(),
      'updatedAt': profile.updatedAt.toIso8601String(),
      'currentStreak': profile.currentStreak,
    });
  }

  static UserProfile? getUserProfile() {
    final box = Hive.box(userBox);
    final data = box.get('profile') as Map?;
    if (data == null) return null;

    return UserProfile(
      name: data['name'],
      age: data['age'],
      height: data['height'],
      weight: data['weight'],
      gender: data['gender'],
      activityLevel: data['activityLevel'],
      goal: data['goal'],
      dietType: data['dietType'] ?? 'standard',
      measurementSystem: data['measurementSystem'] ?? 'metric',
      dailyCalorieTarget: data['dailyCalorieTarget'],
      proteinTarget: data['proteinTarget'],
      carbsTarget: data['carbsTarget'],
      fatsTarget: data['fatsTarget'],
      waterTarget: data['waterTarget'],
      createdAt: DateTime.parse(data['createdAt']),
      updatedAt: DateTime.parse(data['updatedAt']),
      currentStreak: data['currentStreak'] ?? 0,
    );
  }

  // Food Items
  static Future<void> saveFoodItem(FoodItem item) async {
    final box = Hive.box(foodItemsBox);
    await box.put(item.id, {
      'id': item.id,
      'name': item.name,
      'barcode': item.barcode,
      'servingSize': item.servingSize,
      'calories': item.calories,
      'protein': item.protein,
      'carbs': item.carbs,
      'fats': item.fats,
      'fiber': item.fiber,
      'sugar': item.sugar,
      'sodium': item.sodium,
      'category': item.category,
      'isCustom': item.isCustom,
      'imageUrl': item.imageUrl,
    });
  }

  static List<FoodItem> getAllFoodItems() {
    try {
      final box = Hive.box(foodItemsBox);
      return box.values
          .map((m) {
            if (m is! Map) return null;
            return FoodItem(
              id: m['id'] ?? '',
              name: m['name'] ?? 'Unknown',
              barcode: m['barcode'] ?? '',
              servingSize: (m['servingSize'] as num?)?.toDouble() ?? 100.0,
              calories: (m['calories'] as num?)?.toDouble() ?? 0.0,
              protein: (m['protein'] as num?)?.toDouble() ?? 0.0,
              carbs: (m['carbs'] as num?)?.toDouble() ?? 0.0,
              fats: (m['fats'] as num?)?.toDouble() ?? 0.0,
              fiber: (m['fiber'] as num?)?.toDouble() ?? 0.0,
              sugar: (m['sugar'] as num?)?.toDouble() ?? 0.0,
              sodium: (m['sodium'] as num?)?.toDouble() ?? 0.0,
              category: m['category'] ?? 'other',
              isCustom: m['isCustom'] ?? false,
              imageUrl: m['imageUrl'],
            );
          })
          .whereType<FoodItem>()
          .toList();
    } catch (e) {
      debugPrint('Error loading food items: $e');
      return [];
    }
  }

  static List<FoodItem> searchFoodItems(String query) {
    return getAllFoodItems()
        .where((item) => item.name.toLowerCase().contains(query.toLowerCase()))
        .toList();
  }

  static FoodItem? getFoodItemByBarcode(String barcode) {
    final items = getAllFoodItems();
    try {
      return items.firstWhere((item) => item.barcode == barcode);
    } catch (e) {
      return null;
    }
  }

  static FoodItem? getFoodItemById(String id) {
    final items = getAllFoodItems();
    try {
      return items.firstWhere((item) => item.id == id);
    } catch (e) {
      return null;
    }
  }

  // Food Logs
  static Future<void> saveFoodLog(FoodLog log) async {
    final box = Hive.box(foodLogsBox);
    await box.put(log.id, {
      'id': log.id,
      'foodItemId': log.foodItemId,
      'foodName': log.foodName,
      'servings': log.servings,
      'timestamp': log.timestamp.toIso8601String(),
      'mealType': log.mealType,
      'calories': log.calories,
      'protein': log.protein,
      'carbs': log.carbs,
      'fats': log.fats,
      'notes': log.notes,
      'photoPath': log.photoPath,
    });
  }

  static List<FoodLog> getFoodLogsForDate(DateTime date) {
    try {
      final box = Hive.box(foodLogsBox);
      final dateKey =
          '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
      return box.values
          .map((m) {
            if (m is! Map) return null;
            try {
              final timestamp = DateTime.parse(m['timestamp']);
              final logDateKey =
                  '${timestamp.year}-${timestamp.month.toString().padLeft(2, '0')}-${timestamp.day.toString().padLeft(2, '0')}';
              if (logDateKey == dateKey) {
                return FoodLog(
                  id: m['id'] ?? '',
                  foodItemId: m['foodItemId'] ?? '',
                  foodName: m['foodName'] ?? 'Unknown',
                  servings: (m['servings'] as num?)?.toDouble() ?? 1.0,
                  timestamp: timestamp,
                  mealType: m['mealType'] ?? 'snack',
                  calories: (m['calories'] as num?)?.toDouble() ?? 0.0,
                  protein: (m['protein'] as num?)?.toDouble() ?? 0.0,
                  carbs: (m['carbs'] as num?)?.toDouble() ?? 0.0,
                  fats: (m['fats'] as num?)?.toDouble() ?? 0.0,
                  notes: m['notes'],
                  photoPath: m['photoPath'],
                );
              }
            } catch (e) {
              debugPrint('Error parsing food log: $e');
            }
            return null;
          })
          .whereType<FoodLog>()
          .toList()
        ..sort((a, b) => a.timestamp.compareTo(b.timestamp));
    } catch (e) {
      debugPrint('Error loading food logs: $e');
      return [];
    }
  }

  static Future<void> deleteFoodLog(String id) async {
    final box = Hive.box(foodLogsBox);
    await box.delete(id);
  }

  // Weight Logs
  static Future<void> saveWeightLog(WeightLog log) async {
    final box = Hive.box(weightLogsBox);
    await box.put(log.id, {
      'id': log.id,
      'weight': log.weight,
      'timestamp': log.timestamp.toIso8601String(),
      'notes': log.notes,
      'photoPath': log.photoPath,
    });
  }

  static List<WeightLog> getAllWeightLogs() {
    try {
      final box = Hive.box(weightLogsBox);
      return box.values
          .map((m) {
            if (m is! Map) return null;
            try {
              return WeightLog(
                id: m['id'] ?? '',
                weight: (m['weight'] as num?)?.toDouble() ?? 0.0,
                timestamp: DateTime.parse(m['timestamp']),
                notes: m['notes'],
                photoPath: m['photoPath'],
              );
            } catch (e) {
              debugPrint('Error parsing weight log: $e');
              return null;
            }
          })
          .whereType<WeightLog>()
          .toList()
        ..sort((a, b) => a.timestamp.compareTo(b.timestamp));
    } catch (e) {
      debugPrint('Error loading weight logs: $e');
      return [];
    }
  }

  static Future<void> deleteWeightLog(String id) async {
    final box = Hive.box(weightLogsBox);
    await box.delete(id);
  }

  // Water Logs
  static Future<void> saveWaterLog(WaterLog log) async {
    final box = Hive.box(waterLogsBox);
    await box.put(log.id, {
      'id': log.id,
      'amount': log.amount,
      'timestamp': log.timestamp.toIso8601String(),
    });
  }

  static List<WaterLog> getWaterLogsForDate(DateTime date) {
    final box = Hive.box(waterLogsBox);
    final dateKey =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
    return box.values
        .map((m) {
          final timestamp = DateTime.parse(m['timestamp']);
          final logDateKey =
              '${timestamp.year}-${timestamp.month.toString().padLeft(2, '0')}-${timestamp.day.toString().padLeft(2, '0')}';
          if (logDateKey == dateKey) {
            return WaterLog(
              id: m['id'],
              amount: m['amount'],
              timestamp: timestamp,
            );
          }
          return null;
        })
        .where((log) => log != null)
        .cast<WaterLog>()
        .toList();
  }

  // Settings
  static Future<void> saveSetting(String key, dynamic value) async {
    final box = Hive.box(settingsBox);
    await box.put(key, value);
  }

  static dynamic getSetting(String key, {dynamic defaultValue}) {
    final box = Hive.box(settingsBox);
    return box.get(key, defaultValue: defaultValue);
  }

  // Meal Plans
  static Future<void> saveMealPlan(MealPlan plan) async {
    final box = Hive.box(mealPlansBox);
    await box.put(plan.id, plan.toMap());
  }

  static List<MealPlan> getAllMealPlans() {
    final box = Hive.box(mealPlansBox);
    return box.values
        .map((m) => MealPlan.fromMap(Map<String, dynamic>.from(m)))
        .toList();
  }

  static List<MealPlan> getMealPlansByDay(String dayOfWeek) {
    return getAllMealPlans()
        .where(
          (plan) => plan.dayOfWeek.toLowerCase() == dayOfWeek.toLowerCase(),
        )
        .toList();
  }

  static MealPlan? getMealPlanById(String id) {
    final box = Hive.box(mealPlansBox);
    final data = box.get(id);
    if (data != null) {
      return MealPlan.fromMap(Map<String, dynamic>.from(data));
    }
    return null;
  }

  static Future<void> deleteMealPlan(String id) async {
    final box = Hive.box(mealPlansBox);
    await box.delete(id);
  }

  // Recipe methods
  static Future<void> saveRecipe(Recipe recipe) async {
    final box = Hive.box(recipesBox);
    await box.put(recipe.id, recipe.toMap());
  }

  static List<Recipe> getAllRecipes() {
    final box = Hive.box(recipesBox);
    return box.values
        .map((e) => Recipe.fromMap(Map<String, dynamic>.from(e)))
        .toList();
  }

  static Recipe? getRecipeById(String id) {
    final box = Hive.box(recipesBox);
    final data = box.get(id);
    if (data != null) {
      return Recipe.fromMap(Map<String, dynamic>.from(data));
    }
    return null;
  }

  static Future<void> deleteRecipe(String id) async {
    final box = Hive.box(recipesBox);
    await box.delete(id);
  }

  // Clear all data (for logout/reset)
  static Future<void> clearAllData() async {
    await Hive.box(userBox).clear();
    await Hive.box(foodLogsBox).clear();
    await Hive.box(weightLogsBox).clear();
    await Hive.box(waterLogsBox).clear();
    await Hive.box(mealPlansBox).clear();
    // Keep food items database
  }
}
